// This is my autototem thing i made, works good on servers
// v2.3 - fixed some bugs and made it more legit
package me.alpha432.oyvey.features.modules.combat;

import me.alpha432.oyvey.features.modules.Module;
import me.alpha432.oyvey.features.settings.Setting;
import me.alpha432.oyvey.event.impl.UpdateEvent;
import me.alpha432.oyvey.event.impl.PacketEvent;
import me.alpha432.oyvey.event.system.Subscribe;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.ShieldItem;
import net.minecraft.network.protocol.game.ServerboundContainerClickPacket;
import net.minecraft.network.protocol.game.ServerboundContainerClosePacket;
import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
import net.minecraft.world.inventory.ClickType;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.InteractionHand;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.client.gui.screens.inventory.InventoryScreen;
import net.minecraft.client.gui.screens.inventory.ContainerScreen;
import java.util.Random;

public class AutoTotem extends Module {
    
    // settings i tweaked for different servers
    public Setting<Boolean> enable = new Setting<>("Enable", true);
    public Setting<Mode> mode = new Setting<>("Mode", Mode.SMART);
    public Setting<Integer> health = new Setting<>("Health", 10, 1, 36);
    public Setting<Boolean> fall = new Setting<>("Fall", true);
    public Setting<Integer> fallDist = new Setting<>("FallDist", 8, 3, 50);
    public Setting<Boolean> fire = new Setting<>("Fire", true);
    public Setting<Boolean> openInv = new Setting<>("OpenInv", false); // some servers detect this
    public Setting<Boolean> clickSim = new Setting<>("ClickSim", true);
    public Setting<Integer> delay = new Setting<>("Delay", 150, 50, 1000);
    public Setting<Boolean> random = new Setting<>("Random", true);
    public Setting<Boolean> sound = new Setting<>("Sound", false); // might be loud
    public Setting<Boolean> closeInv = new Setting<>("CloseInv", true);
    public Setting<Boolean> hotbar = new Setting<>("Hotbar", false);
    public Setting<Boolean> shield = new Setting<>("Shield", true);
    
    // my variables
    private int totems = 0;
    private int shields = 0;
    private boolean hasTotem = false;
    private boolean hasShield = false;
    private boolean invOpen = false;
    private boolean working = false;
    private int cooldown = 0;
    private int tries = 0;
    private int lastHP = 0;
    private int danger = 0;
    private final Random rand = new Random();
    
    // for tracking
    private long lastAction = 0;
    private boolean wasHit = false;
    
    public AutoTotem() {
        super("AutoTotem", "puts totem in offhand when low", Category.COMBAT);
    }
    
    @Subscribe
    public void onUpdate(UpdateEvent event) {
        if (!isEnabled() || !enable.getValue() || mc.player == null || mc.level == null) return;
        
        // update cooldown
        if (cooldown > 0) cooldown--;
        
        // check inv
        invOpen = mc.screen instanceof InventoryScreen;
        
        // count stuff
        countItems();
        
        // check if we need totem
        updateDanger();
        
        // dont spam
        if (cooldown > 0) return;
        if (working) return;
        
        // decide what to do
        boolean needTotem = checkNeedTotem();
        boolean canTotem = totems > 0 && !hasTotem;
        
        if (needTotem && canTotem) {
            // time to switch
            startSwitch();
        } else if (hasTotem && !needTotem && shield.getValue() && shields > 0) {
            // maybe switch to shield
            if (rand.nextInt(100) < 20) { // 20% chance
                switchToShield();
            }
        }
        
        // remember hp
        lastHP = (int) mc.player.getHealth();
    }
    
    private void countItems() {
        totems = 0;
        shields = 0;
        
        Inventory inv = mc.player.getInventory();
        for (int i = 0; i < inv.getContainerSize(); i++) {
            ItemStack stack = inv.getItem(i);
            if (stack.isEmpty()) continue;
            
            if (stack.getItem() == Items.TOTEM_OF_UNDYING) {
                totems += stack.getCount();
            } else if (stack.getItem() instanceof ShieldItem) {
                shields += stack.getCount();
            }
        }
        
        hasTotem = mc.player.getOffhandItem().getItem() == Items.TOTEM_OF_UNDYING;
        hasShield = mc.player.getOffhandItem().getItem() instanceof ShieldItem;
    }
    
    private void updateDanger() {
        danger = 0;
        
        // health check
        float hpPercent = mc.player.getHealth() / mc.player.getMaxHealth();
        if (hpPercent < 0.3f) danger += 3;
        else if (hpPercent < 0.6f) danger += 2;
        else if (hpPercent < 0.8f) danger += 1;
        
        // fall check
        if (fall.getValue() && mc.player.fallDistance > fallDist.getValue()) {
            danger += 2;
        }
        
        // fire check
        if (fire.getValue() && mc.player.isOnFire()) {
            danger += 2;
        }
        
        // just got hit
        if (mc.player.hurtTime > 0) {
            danger += 2;
            wasHit = true;
        } else {
            wasHit = false;
        }
        
        // big damage
        if (lastHP > 0 && (lastHP - mc.player.getHealth()) > 5) {
            danger += 3;
        }
        
        // cap it
        if (danger > 5) danger = 5;
    }
    
    private boolean checkNeedTotem() {
        if (mode.getValue() == Mode.ALWAYS) {
            return true;
        } else if (mode.getValue() == Mode.SMART) {
            return danger >= 3;
        } else if (mode.getValue() == Mode.AGGRESSIVE) {
            return danger >= 2 || wasHit;
        } else if (mode.getValue() == Mode.SAFE) {
            return danger >= 4;
        }
        return false;
    }
    
    private void startSwitch() {
        working = true;
        tries = 0;
        
        // open inv if needed
        if (openInv.getValue() && !invOpen) {
            openInventory();
            // wait a bit
            new Thread(() -> {
                try {
                    Thread.sleep(getDelay());
                    if (mc.player != null) {
                        mc.execute(this::findAndSwitch);
                    }
                } catch (InterruptedException e) {
                    // whatever
                }
            }).start();
        } else {
            findAndSwitch();
        }
        
        cooldown = 3; // small cooldown
        lastAction = System.currentTimeMillis();
    }
    
    private void openInventory() {
        if (mc.screen == null) {
            mc.player.sendOpenInventory();
            if (sound.getValue()) {
                playSound(SoundEvents.CHEST_OPEN, 0.4f);
            }
        }
    }
    
    private void findAndSwitch() {
        int totemSlot = findTotem();
        if (totemSlot == -1) {
            working = false;
            return;
        }
        
        // do the switch
        if (clickSim.getValue()) {
            // use container click (more legit)
            doContainerSwitch(totemSlot);
        } else {
            // direct switch (faster)
            doDirectSwitch(totemSlot);
        }
        
        // close inv
        if (closeInv.getValue() && invOpen) {
            closeInventory();
        }
        
        working = false;
        
        // play sound
        if (sound.getValue()) {
            playSound(SoundEvents.ITEM_PICKUP, 0.3f);
        }
    }
    
    private int findTotem() {
        Inventory inv = mc.player.getInventory();
        
        // check hotbar first if enabled
        if (hotbar.getValue()) {
            for (int i = 0; i < 9; i++) {
                if (inv.getItem(i).getItem() == Items.TOTEM_OF_UNDYING) {
                    return i;
                }
            }
            return -1;
        }
        
        // check all slots
        for (int i = 0; i < inv.getContainerSize(); i++) {
            if (inv.getItem(i).getItem() == Items.TOTEM_OF_UNDYING) {
                return i;
            }
        }
        
        return -1;
    }
    
    private void doContainerSwitch(int fromSlot) {
        if (mc.player.containerMenu == null) return;
        
        // offhand is slot 45
        ServerboundContainerClickPacket packet = new ServerboundContainerClickPacket(
            mc.player.containerMenu.containerId,
            mc.player.containerMenu.getStateId(),
            fromSlot,
            0,
            ClickType.QUICK_MOVE,
            ItemStack.EMPTY,
            mc.player.containerMenu.getSlot(fromSlot).getItem()
        );
        
        mc.player.connection.send(packet);
    }
    
    private void doDirectSwitch(int fromSlot) {
        Inventory inv = mc.player.getInventory();
        int offhandSlot = 40; // offhand index
        
        ItemStack totem = inv.getItem(fromSlot).copy();
        ItemStack current = inv.getItem(offhandSlot).copy();
        
        inv.setItem(fromSlot, current);
        inv.setItem(offhandSlot, totem);
        
        // update client
        mc.player.containerMenu.setItem(offhandSlot, 0, totem);
    }
    
    private void switchToShield() {
        int shieldSlot = -1;
        Inventory inv = mc.player.getInventory();
        
        for (int i = 0; i < inv.getContainerSize(); i++) {
            if (inv.getItem(i).getItem() instanceof ShieldItem) {
                shieldSlot = i;
                break;
            }
        }
        
        if (shieldSlot == -1) return;
        
        int offhandSlot = 40;
        ItemStack shield = inv.getItem(shieldSlot).copy();
        ItemStack current = inv.getItem(offhandSlot).copy();
        
        inv.setItem(shieldSlot, current);
        inv.setItem(offhandSlot, shield);
        
        if (sound.getValue()) {
            playSound(SoundEvents.ARMOR_EQUIP_IRON, 0.5f);
        }
    }
    
    private void closeInventory() {
        if (mc.screen instanceof InventoryScreen || mc.screen instanceof ContainerScreen) {
            mc.player.connection.send(new ServerboundContainerClosePacket(mc.player.containerMenu.containerId));
            mc.setScreen(null);
            
            if (sound.getValue()) {
                playSound(SoundEvents.CHEST_CLOSE, 0.4f);
            }
        }
    }
    
    private void playSound(net.minecraft.sounds.SoundEvent sound, float volume) {
        if (mc.level != null) {
            mc.level.playSound(mc.player, mc.player.blockPosition(), 
                sound, SoundSource.PLAYERS, volume, 1.0f);
        }
    }
    
    private long getDelay() {
        if (random.getValue()) {
            return delay.getValue() + rand.nextInt(100) - 50;
        }
        return delay.getValue();
    }
    
    @Subscribe
    public void onPacketReceive(PacketEvent.Receive event) {
        if (!isEnabled() || mc.player == null) return;
        
        // check if totem got used
        if (event.getPacket() instanceof ClientboundContainerSetSlotPacket packet) {
            if (packet.getSlot() == 45) { // offhand slot
                ItemStack newItem = packet.getItem();
                boolean nowHasTotem = newItem.getItem() == Items.TOTEM_OF_UNDYING;
                
                if (nowHasTotem != hasTotem) {
                    hasTotem = nowHasTotem;
                    if (nowHasTotem && sound.getValue()) {
                        playSound(SoundEvents.TOTEM_USE, 1.0f);
                    }
                }
            }
        }
    }
    
    @Override
    public void onEnable() {
        totems = 0;
        shields = 0;
        hasTotem = false;
        hasShield = false;
        working = false;
        cooldown = 0;
        tries = 0;
        lastHP = mc.player != null ? (int) mc.player.getHealth() : 0;
        danger = 0;
        wasHit = false;
        lastAction = 0;
    }
    
    @Override
    public void onDisable() {
        // close inv if open
        if (invOpen && mc.screen != null) {
            mc.player.connection.send(new ServerboundContainerClosePacket(mc.player.containerMenu.containerId));
            mc.setScreen(null);
        }
        
        working = false;
    }
    
    @Override
    public String getDisplayInfo() {
        if (!isEnabled()) return null;
        
        if (hasTotem) {
            return "ON" + (totems > 1 ? "(" + (totems - 1) + ")" : "");
        }
        
        if (danger >= 3) {
            return "!";
        }
        
        return null;
    }
    
    // my enums
    public enum Mode {
        SMART("Smart"),
        AGGRESSIVE("Aggro"),
        SAFE("Safe"),
        ALWAYS("Always");
        
        private final String name;
        
        Mode(String name) {
            this.name = name;
        }
        
        @Override
        public String toString() {
            return name;
        }
    }
    
    // some helper methods i might use elsewhere
    public boolean isProtected() { return hasTotem; }
    public int getTotemsLeft() { return totems; }
    public int getDanger() { return danger; }
}
