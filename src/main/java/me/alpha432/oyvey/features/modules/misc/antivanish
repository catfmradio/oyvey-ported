package me.alpha432.oyvey.features.modules.combat;

import me.alpha432.oyvey.features.modules.Module;
import me.alpha432.oyvey.features.settings.Setting;
import me.alpha432.oyvey.event.impl.Render3DEvent;
import me.alpha432.oyvey.event.impl.PacketEvent;
import me.alpha432.oyvey.event.impl.UpdateEvent;
import me.alpha432.oyvey.event.system.Subscribe;
import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.phys.Vec3;
import net.minecraft.network.chat.Component;
import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.blaze3d.vertex.VertexConsumer;
import net.minecraft.client.renderer.RenderType;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class AntiVanish extends Module {
    // Settings
    private final Setting<Boolean> alert = new Setting<>("Alert", true);
    private final Setting<Boolean> trackMovement = new Setting<>("TrackMovement", true);
    private final Setting<Boolean> showTrail = new Setting<>("ShowTrail", true);
    private final Setting<Integer> trailLength = new Setting<>("TrailLength", 20, 5, 100);
    private final Setting<Float> renderDistance = new Setting<>("RenderDistance", 64.0f, 16.0f, 256.0f);
    private final Setting<Boolean> playSound = new Setting<>("PlaySound", true);
    private final Setting<Boolean> logToFile = new Setting<>("LogToFile", false);
    
    // Vanish detection data
    private final Map<UUID, VanishData> vanishedPlayers = new ConcurrentHashMap<>();
    private final Map<UUID, List<Vec3>> playerTrails = new ConcurrentHashMap<>();
    private final Set<UUID> recentlyDetected = new HashSet<>();
    
    private int tickCounter = 0;
    
    public AntiVanish() {
        super("AntiVanish", "Detects vanished/ghost players", Category.COMBAT);
    }
    
    @Subscribe
    public void onPacketReceive(PacketEvent.Receive event) {
        if (!isEnabled() || mc.level == null) return;
        
        // Detect player removal packets (common vanish method)
        if (event.getPacket() instanceof ClientboundRemoveEntitiesPacket packet) {
            for (int id : packet.getEntityIds()) {
                Entity entity = mc.level.getEntity(id);
                if (entity instanceof Player player && player != mc.player) {
                    handleVanishDetection(player);
                }
            }
        }
        
        // Detect player info updates (vanished players might still send updates)
        if (event.getPacket() instanceof ClientboundPlayerInfoUpdatePacket packet) {
            packet.entries().forEach(entry -> {
                Player player = mc.level.getPlayerByUUID(entry.profileId());
                if (player != null && !player.isAlive() && vanishedPlayers.containsKey(entry.profileId())) {
                    // Vanished player sending updates
                    updateVanishedPlayer(entry.profileId(), player.position());
                }
            });
        }
        
        // Detect teleport packets for vanished entities
        if (event.getPacket() instanceof ClientboundTeleportEntityPacket packet) {
            Entity entity = mc.level.getEntity(packet.getId());
            if (entity instanceof Player player && vanishedPlayers.containsKey(player.getUUID())) {
                updateVanishedPlayer(player.getUUID(), new Vec3(packet.getX(), packet.getY(), packet.getZ()));
            }
        }
    }
    
    @Subscribe
    public void onUpdate(UpdateEvent event) {
        if (!isEnabled() || mc.level == null) return;
        
        tickCounter++;
        
        // Periodic cleanup
        if (tickCounter % 100 == 0) {
            cleanOldData();
        }
        
        // Check for vanished players that should be visible
        Iterator<Map.Entry<UUID, VanishData>> iterator = vanishedPlayers.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<UUID, VanishData> entry = iterator.next();
            VanishData data = entry.getValue();
            
            // Check if player reappeared
            Player player = mc.level.getPlayerByUUID(entry.getKey());
            if (player != null && player.isAlive()) {
                if (alert.getValue()) {
                    sendMessage("§c[AntiVanish] §f" + player.getName().getString() + " §7reappeared after " + 
                               (mc.level.getGameTime() - data.vanishTime) + " ticks");
                }
                iterator.remove();
                playerTrails.remove(entry.getKey());
                continue;
            }
            
            // Update trail if tracking movement
            if (trackMovement.getValue() && data.lastKnownPosition != null) {
                playerTrails.computeIfAbsent(entry.getKey(), k -> new ArrayList<>())
                           .add(data.lastKnownPosition);
                
                // Trim trail to specified length
                List<Vec3> trail = playerTrails.get(entry.getKey());
                if (trail.size() > trailLength.getValue()) {
                    trail = trail.subList(trail.size() - trailLength.getValue(), trail.size());
                    playerTrails.put(entry.getKey(), trail);
                }
            }
        }
        
        // Reset recently detected set periodically
        if (tickCounter % 200 == 0) {
            recentlyDetected.clear();
        }
    }
    
    @Subscribe
    public void onRender3D(Render3DEvent event) {
        if (!isEnabled() || mc.player == null || mc.level == null) return;
        
        PoseStack poseStack = event.getPoseStack();
        float partialTicks = event.getPartialTicks();
        
        // Render vanished players and their trails
        for (Map.Entry<UUID, VanishData> entry : vanishedPlayers.entrySet()) {
            VanishData data = entry.getValue();
            
            if (data.lastKnownPosition == null) continue;
            
            double distance = mc.player.position().distanceTo(data.lastKnownPosition);
            if (distance > renderDistance.getValue()) continue;
            
            // Render player position
            renderVanishedPlayer(poseStack, data, partialTicks);
            
            // Render trail if enabled
            if (showTrail.getValue() && playerTrails.containsKey(entry.getKey())) {
                renderPlayerTrail(poseStack, entry.getKey(), partialTicks);
            }
        }
    }
    
    private void handleVanishDetection(Player player) {
        UUID uuid = player.getUUID();
        
        // Prevent spam detection
        if (recentlyDetected.contains(uuid)) return;
        
        VanishData data = vanishedPlayers.get(uuid);
        if (data == null) {
            // New vanish detection
            data = new VanishData(player, mc.level.getGameTime());
            vanishedPlayers.put(uuid, data);
            
            if (alert.getValue()) {
                sendMessage("§c[AntiVanish] §f" + player.getName().getString() + " §7may have vanished!");
                if (playSound.getValue()) {
                    // Play detection sound (implementation depends on sound system)
                    // mc.player.playSound(SoundEvents.ENTITY_EXPERIENCE_ORB_PICKUP, 1.0f, 1.0f);
                }
            }
            
            if (logToFile.getValue()) {
                logVanishToFile(player);
            }
        } else {
            // Update existing vanish data
            data.lastSeen = mc.level.getGameTime();
            data.lastKnownPosition = player.position();
        }
        
        recentlyDetected.add(uuid);
    }
    
    private void updateVanishedPlayer(UUID uuid, Vec3 position) {
        VanishData data = vanishedPlayers.get(uuid);
        if (data != null) {
            data.lastKnownPosition = position;
            data.lastSeen = mc.level.getGameTime();
            
            // Add to trail if tracking
            if (trackMovement.getValue()) {
                playerTrails.computeIfAbsent(uuid, k -> new ArrayList<>())
                           .add(position);
            }
        }
    }
    
    private void renderVanishedPlayer(PoseStack poseStack, VanishData data, float partialTicks) {
        if (data.lastKnownPosition == null) return;
        
        // Calculate interpolated position
        double x = data.lastKnownPosition.x;
        double y = data.lastKnownPosition.y;
        double z = data.lastKnownPosition.z;
        
        // Render a ghostly outline or marker at the vanished player's position
        // This is pseudocode - actual rendering depends on your render system
        /*
        poseStack.pushPose();
        poseStack.translate(x - mc.getEntityRenderDispatcher().camera.getX(),
                           y - mc.getEntityRenderDispatcher().camera.getY(),
                           z - mc.getEntityRenderDispatcher().camera.getZ());
        
        // Render ghost player model or marker
        VertexConsumer buffer = mc.renderBuffers().bufferSource().getBuffer(RenderType.LINES);
        // Draw bounding box or player outline
        
        poseStack.popPose();
        */
        
        // Render name tag
        String nameTag = data.playerName + " §8[Vanished]";
        // renderNametag(poseStack, nameTag, x, y + 2.0, z);
    }
    
    private void renderPlayerTrail(PoseStack poseStack, UUID uuid, float partialTicks) {
        List<Vec3> trail = playerTrails.get(uuid);
        if (trail == null || trail.size() < 2) return;
        
        // Render trail as connected lines
        // This is pseudocode - actual rendering depends on your render system
        /*
        VertexConsumer buffer = mc.renderBuffers().bufferSource().getBuffer(RenderType.LINES);
        
        for (int i = 0; i < trail.size() - 1; i++) {
            Vec3 start = trail.get(i);
            Vec3 end = trail.get(i + 1);
            
            // Calculate alpha based on trail position (fade out older segments)
            float alpha = (float) i / trail.size();
            
            // Draw line from start to end
            // renderLine(poseStack, buffer, start, end, 1.0f, 0.5f, 0.5f, 0.5f * (1 - alpha));
        }
        */
    }
    
    private void cleanOldData() {
        long currentTime = mc.level != null ? mc.level.getGameTime() : 0;
        Iterator<Map.Entry<UUID, VanishData>> iterator = vanishedPlayers.entrySet().iterator();
        
        while (iterator.hasNext()) {
            Map.Entry<UUID, VanishData> entry = iterator.next();
            VanishData data = entry.getValue();
            
            // Remove data older than 1 minute (1200 ticks)
            if (currentTime - data.lastSeen > 1200) {
                iterator.remove();
                playerTrails.remove(entry.getKey());
            }
        }
    }
    
    private void logVanishToFile(Player player) {
        try {
            // Log vanish detection to file
            // Implementation depends on your logging system
            /*
            String logEntry = String.format("[%s] %s vanished at %.1f, %.1f, %.1f",
                new Date(),
                player.getName().getString(),
                player.getX(), player.getY(), player.getZ());
            
            Files.write(Paths.get("vanish_log.txt"), 
                       (logEntry + System.lineSeparator()).getBytes(),
                       StandardOpenOption.CREATE, StandardOpenOption.APPEND);
            */
        } catch (Exception e) {
            // Silent fail
        }
    }
    
    private void sendMessage(String message) {
        if (mc.player != null) {
            mc.player.sendSystemMessage(Component.literal(message));
        }
    }
    
    @Override
    public void onEnable() {
        vanishedPlayers.clear();
        playerTrails.clear();
        recentlyDetected.clear();
        tickCounter = 0;
        
        if (alert.getValue()) {
            sendMessage("§a[AntiVanish] §fEnabled");
        }
    }
    
    @Override
    public void onDisable() {
        if (alert.getValue() && !vanishedPlayers.isEmpty()) {
            sendMessage("§c[AntiVanish] §fDisabled - " + vanishedPlayers.size() + " vanished players cleared");
        }
        vanishedPlayers.clear();
        playerTrails.clear();
    }
    
    @Override
    public String getDisplayInfo() {
        return vanishedPlayers.isEmpty() ? null : vanishedPlayers.size() + "";
    }
    
    // Data class for vanish tracking
    private static class VanishData {
        public final String playerName;
        public final long vanishTime;
        public long lastSeen;
        public Vec3 lastKnownPosition;
        
        public VanishData(Player player, long vanishTime) {
            this.playerName = player.getName().getString();
            this.vanishTime = vanishTime;
            this.lastSeen = vanishTime;
            this.lastKnownPosition = player.position();
        }
    }
    
    // Helper method to check if a player is currently detected as vanished
    public boolean isPlayerVanished(UUID uuid) {
        return vanishedPlayers.containsKey(uuid);
    }
    
    // Get vanished player's last known position
    public Vec3 getVanishedPlayerPosition(UUID uuid) {
        VanishData data = vanishedPlayers.get(uuid);
        return data != null ? data.lastKnownPosition : null;
    }
    
    // Get all vanished players
    public Set<UUID> getVanishedPlayers() {
        return Collections.unmodifiableSet(vanishedPlayers.keySet());
    }
}
